from flask import Flask, jsonify, request, send_from_directory, session
from flask_cors import CORS
from flask_session import Session
import json
import os
import openai
import sys
import requests
from dotenv import load_dotenv

print("‚úÖ ‚úÖ ‚úÖ THIS IS THE REAL main.py FROM videos FOLDER")

# ‚úÖ LEGACY IMPORT VALIDATION
assert openai.__version__.startswith("0.28"), f"WRONG openai VERSION LOADED: {openai.__version__}"

print("‚úÖ main.py loaded and running")

# === Dual-path ENV Loader ===
abs_path = "D:\\RecipeGen\\Tehomia-chatgpt-diagnostics-remix\\.env"
if os.path.exists(abs_path):
    load_dotenv(dotenv_path=abs_path)
    print("‚úÖ Loaded .env from ABSOLUTE path (development)")
elif os.path.exists(".env"):
    load_dotenv()
    print("‚úÖ Loaded .env from RELATIVE path (production-ready)")
else:
    print("‚ùå No .env file found ‚Äî check pathing before deployment.")

print("‚úÖ Loaded API KEY (active load):", os.getenv("OPENAI_API_KEY"))

# üîΩ ENVIRONMENT DIAGNOSTICS
print("‚öôÔ∏è ENVIRONMENT DIAGNOSTIC")
print(f"Python Executable : {sys.executable}")
print(f"Python Version    : {sys.version}")
print(f"OpenAI Version    : {openai.__version__}")
print(f"OpenAI Path       : {openai.__file__}")
print(f"ENV Variable OPENAI_API_KEY: {os.getenv('OPENAI_API_KEY')}")

# === Load Data ===
with open('data/recipes.json') as f:
    recipes = json.load(f)

with open('data/history.json') as f:
    history = json.load(f)

with open("data/ingredients.json", encoding="utf-8") as f:
    INGREDIENTS_LIST = json.load(f)
    INGREDIENTS_BY_SLUG = {item["slug"]: item for item in INGREDIENTS_LIST}

# === Assign Keys ===
openai.api_key = os.getenv("OPENAI_API_KEY")

app = Flask(__name__, static_url_path='/static', static_folder='static')
app.secret_key = 'supersecretkey'
app.config['SESSION_TYPE'] = 'filesystem'
Session(app)
CORS(app)

# ‚úÖ Blueprint registration
from video_routes import video_bp
app.register_blueprint(video_bp)

# === Utility: Strict RecipeGen Chat Guardrail ===
def is_recipegen_related(message):
    allowed_keywords = [
        "recipe", "cook", "cooking", "bake", "baking", "ingredients", "ingredient",
        "dish", "meal", "prepare", "make", "food", "kitchen", "generate", "select",
        "category", "history", "video", "image", "site", "login", "account", "chat", "how to use"
    ]
    msg = message.lower()
    return any(kw in msg for kw in allowed_keywords)

def is_food_related(text):
    food_words = [
        "cook", "boil", "bake", "roast", "grill", "simmer", "chill", "refrigerate",
        "saute", "steam", "blend", "prep", "recipe", "dish", "ingredient", "oven",
        "microwave", "fry", "deep fry", "mince", "whisk", "dough", "batter", "rice", "meat"
    ]
    return any(word in text for word in food_words)

def is_geography_question(text):
    patterns = [
        "how long", "how far", "distance from", "distance to", "how many miles", "how many kilometers",
        "travel from", "travel to", "flight from", "flight to", "directions to"
    ]
    return any(p in text for p in patterns)

def validate_ingredients(ingredient_slugs, mode="jewish"):
    problems = []
    
    if mode != "jewish":
        return problems
    
    types_present = set()
    meat_names = []
    fish_names = []
    dairy_names = []
    
    for slug in ingredient_slugs:
        ing = INGREDIENTS_BY_SLUG.get(slug)
        if not ing:
            problems.append({"slug": slug, "error": "Unknown ingredient"})
            continue
        
        ing_type = ing.get("type")
        kashrut = ing.get("kashrut")
        
        # Check for non-kosher items
        if kashrut == "non-kosher":
            problems.append({
                "slug": slug,
                "error": f"{ing['name']} is not permitted in Jewish cuisine."
            })
        
        # Track types for mixing validation
        if ing_type:
            types_present.add(ing_type)
            
            # Track kosher items for mixing rules
            if ing_type == "meat" and kashrut == "kosher":
                meat_names.append(ing['name'])
            elif ing_type == "fish" and kashrut == "kosher":
                fish_names.append(ing['name'])
            elif ing_type == "dairy":
                dairy_names.append(ing['name'])
    
    # Check for meat + dairy mixing
    if meat_names and dairy_names:
        problems.append({
            "error": "Our Jewish cuisine follows kosher law, which prohibits the mixture of meat and dairy products."
        })
    
    # Check for meat + fish mixing  
    if meat_names and fish_names:
        problems.append({
            "error": "Our Jewish cuisine follows kosher law, which prohibits the mixture of meat and fish."
        })
    
    return problems

# === Routes ===

@app.route('/categories', methods=['GET'])
def get_categories():
    categories = list({r['category'] for r in recipes})
    return jsonify(categories)

@app.route('/recipes', methods=['GET'])
def get_recipes():
    category = request.args.get('category')
    if category:
        filtered = [r for r in recipes if r['category'].lower() == category.lower()]
        return jsonify(filtered)
    return jsonify(recipes)

@app.route('/recipes/<int:recipe_id>', methods=['GET'])
def get_recipe(recipe_id):
    for r in recipes:
        if r['id'] == recipe_id:
            return jsonify(r)
    return jsonify({'error': 'Recipe not found'}), 404

@app.route('/recipes/<int:recipe_id>/generate', methods=['POST'])
def generate_recipe(recipe_id):
    for r in recipes:
        if r['id'] == recipe_id:
            entry = {'recipe_id': recipe_id, 'title': r['title']}
            history.append(entry)
            with open('data/history.json', 'w') as f:
                json.dump(history, f, indent=2)
            return jsonify({'instructions': 'Step-by-step instructions will appear here.'})
    return jsonify({'error': 'Recipe not found'}), 404

@app.route('/validate_ingredients', methods=['POST'])
def validate_ingredients_api():
    try:
        data = request.get_json(force=True)
        ingredient_slugs = data.get("ingredients", [])
        mode = data.get("mode", "jewish")
        problems = validate_ingredients(ingredient_slugs, mode=mode)
        return jsonify({"problems": problems, "count": len(problems)})
    except Exception as e:
        return jsonify({"error": "Validation failed", "details": str(e)}), 500

@app.route('/history', methods=['GET'])
def get_history():
    return jsonify(history)

@app.route('/login', methods=['POST'])
def login():
    credentials = request.json
    if credentials.get('username') == 'admin' and credentials.get('password') == 'password123':
        session['user'] = 'admin'
        return jsonify({'status': 'success'})
    return jsonify({'status': 'failure'}), 401

@app.route("/ingredients", methods=["GET"])
def get_ingredients():
    try:
        with open("data/ingredients.json", "r", encoding="utf-8") as f:
            ingredients = json.load(f)
        return jsonify(ingredients)
    except Exception as e:
        return jsonify({"error": "Unable to load ingredients", "details": str(e)}), 500

@app.route("/chat", methods=["POST"])
def chat():
    print("üîµ /chat route hit")
    data = request.get_json(force=True)
    if not data or "message" not in data:
        print("üî¥ No message found in payload.")
        return jsonify({'error': 'Invalid request'}), 400

    user_message = data["message"].strip()
    print("üü¢ User message:", user_message)
    text = user_message.lower()

    off_topic_patterns = [
        "president", "trump", "biden", "putin", "election", "politics",
        "soccer", "sex", "intimacy", "sensual", "football", "player", "news", "weather", "stock", "market",
        "company", "business", "music", "movie", "actor", "actress", "sport",
        "game", "science", "math", "state", "number", "capital", "country", "who is", "money",
        "celebrity", "politician", "government", "pandemic", "covid", "virus", "universe", "physics",
        "mount", "mountain", "everest", "how tall", "altitude", "height", "landmark", "show", "gossip",
        "mars", "venus", "jupiter", "planet", "space", "astronomy", "nasa", "moon", "solar system"
    ]

    if any(kw in text for kw in off_topic_patterns):
        return jsonify({
            "reply": (
                "I'm only able to answer questions about recipes, ingredients, cooking, or how to use RecipeGen. "
                "Please ask about food, ingredients, or this site."
            )
        })

    if "login" in text or "log in" in text:
        return jsonify({
            'reply': (
                "To log in, click the ‚ÄúLogin‚Äù link in the top‚Äëright navbar, "
                "enter your username and password, then hit Submit."
            )
        })

    admin_keywords = ["administrator", "admin", "support", "help", "contact", "account", "password"]
    if any(kw in text for kw in admin_keywords):
        return jsonify({
            'reply': (
                "For site‚Äëadministration or support issues, please use the ‚ÄúContact‚Äù "
                "link in the top‚Äëright navbar or email support@recipegen.io."
            )
        })

    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are RecipeGen."},
                {"role": "user", "content": user_message}
            ],
            max_tokens=150
        )
        ai_reply = resp.choices[0].message.content.strip()
        print("üü£ AI reply:", ai_reply)
    except Exception as e:
        print("‚ùå OpenAI error:", e)
        return jsonify({'error': 'Server error'}), 500

    return jsonify(reply=ai_reply)

# ‚úÖ ‚úÖ ‚úÖ NEW FULLY UPGRADED ROUTE BEGINS HERE
@app.route('/generate_video', methods=['POST'])
def generate_video(prompt, duration, output_path):
    provider = os.getenv("USE_PROVIDER", "higgsfield").lower()
    logging.info(f"üéõÔ∏è Video provider selected: {provider}")
    num_frames = duration * 24
    fps = 24
    width = 1024
    height = 576
    guidance_scale = 7.5
    seed = 42

    try:
        if provider == "runway":
            api_key = os.getenv("RUNWAY_API_KEY")
            if not api_key:
                raise ValueError("Missing RUNWAY_API_KEY in environment")

            url = "https://api.runwayml.com/v1/generate"
            headers = {
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json"
            }
            payload = {
                "prompt": prompt,
                "num_frames": num_frames,
                "fps": fps,
                "width": width,
                "height": height,
                "guidance_scale": guidance_scale,
                "seed": seed,
                "motion": "cooking"
            }
            logging.debug(f"üöÄ RUNWAY REQUEST PAYLOAD: {json.dumps(payload, indent=2)}")
            logging.debug(f"üöÄ RUNWAY REQUEST HEADERS: {headers}")

        else:
            api_key = os.getenv("VIDEO_API_KEY")
            if not api_key:
                raise ValueError("Missing VIDEO_API_KEY in environment")

            url = os.getenv("VIDEO_API_BASE", "https://api.higgsfield.ai/generate")
            headers = {
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json"
            }
            payload = {
                "prompt": prompt,
                "duration": duration
            }
            logging.debug(f"üöÄ HIGGSFIELD REQUEST PAYLOAD: {json.dumps(payload, indent=2)}")
            logging.debug(f"üöÄ HIGGSFIELD REQUEST HEADERS: {headers}")

        logging.info(f"üì° Sending POST to: {url}")
        response = requests.post(url, headers=headers, json=payload)
        logging.debug(f"üì® Response Status: {response.status_code}")
        logging.debug(f"üì® Response Body: {response.text}")

        response.raise_for_status()
        result = response.json()

        # Extract video URL from response
        video_url = result.get("video_url") or result.get("url") or None
        if not video_url:
            raise ValueError("No video_url found in response.")

        logging.info(f"üéûÔ∏è Video generated at URL: {video_url}")

        # Download video
        video_data = requests.get(video_url)
        video_data.raise_for_status()
        with open(output_path, "wb") as f:
            f.write(video_data.content)
        logging.info(f"üì• Video saved locally to: {output_path}")

        return video_url

    except Exception as e:
        logging.exception("‚ùå Video generation failed")
        raise RuntimeError(f"Video generation failed: {e}")

@app.route('/ui')
def serve_ui():
    return send_from_directory('static', 'index.html')

@app.route('/')
def root():
    return send_from_directory('static', 'index.html')

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 3000))
    app.run(host="0.0.0.0", port=port)
